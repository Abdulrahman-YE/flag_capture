<h3 style="text-align:center" dir="rtl">بسم الله الرحمن الرحيم </h3>

# Stack Six:
In this level we need to execute a shellcode to spawn a shell. However, its different from stack five level in we can not overwrite the return address from `greet` function because of the if-statment in `greet` .

<br/>

Lets see what happen in `greet` function. This function takes as argument a pointer to char named `who` and return a string (pointer to char).
1. `who` pointer is the pointer that points to the env variable `ExploitEducation`.
2. `buffer` array of size 128 is defined.
3. `maxSize` integer  is defined.
4. `who` array length is calculated and stored in `maxSize`.
5. If `maxSize` is bigger than `buffer` go to line 6 else go to line 7.
6. `Buffer` length is calcualted and subtracted by 1 because the index start from 0 and `strlen` return lastIndex + 1.
7. `what` var is a global variable that takes its value from the macro `GREET` that changes based on the system arch.`what` variable is copied to the `buffer`.In amd64 levels `what` is `Welcome, I am pleased to meet you `.`what` string length is 34(space included).
8. `strncpy` used to ensure that the copy from `who` to the `buffer` is in range of `maxSize` integer.This operation will only copy a maximum of 127 character from `who` to `buffer`. 
9. `strdup` duplicate the `buffer` and store it in heap and return a pointer to that location. The reason to use `strdup` because it stores the string in heap which will not be affected by the destruction of the stack frame of `greet` function.

<br/>

The thing we need to focus on is the copy of `what` and `who` to buffer.
```
strlen(what) = 34
strlen(buffer) = 128 free
"what" copied to "buffer".
The remaining space in buffer = 128 - 34 = 94
maximum allowed size of "who" is 127.
127 copied to buffer.
127 > 94 then the buffer will overwite more than the allowed space for it.
The size of the overflow is 33 byte.
```

### Notes
- To make the exploit work in gdb and out of it make sure that the env variables in gdb is the same as out of gdb.GDB add extra env variables to unset them use `unset env VARIABLE_NAME`

### Reversing The Program :
Disassemble `greet` function :
```bash
(gdb) disas greet
Dump of assembler code for function greet:
   0x00000000004006fd <+0>:	push   rbp
   0x00000000004006fe <+1>:	mov    rbp,rsp
   0x0000000000400701 <+4>:	push   rbx
   0x0000000000400702 <+5>:	sub    rsp,0xa8
                    .
                    .
  <.........................................>
   0x0000000000400791 <+148>:	add    rsp,0xa8
   0x0000000000400798 <+155>:	pop    rbx
   0x0000000000400799 <+156>:	pop    rbp
   0x000000000040079a <+157>:	ret    
End of assembler dump.

```
<br>

- Stack layout after `greet+5` :
```

168 byte subtracted from RSP to make space for local variables and temp variables.
_____________________
previous value of RBX register
______________________
previous frame pointer
______________________
return address to main
```

- At `greet+148` will remove the space for local and temp vars.
- At `greet+155` will restore the previous value of `RBX`
- At `greet+156` will retsore the previous frame pointer to `RBP`
- At `greet+157` will move the return address to `RIP` to continue in `main` function.